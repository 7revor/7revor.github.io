## 锲子
> 写这篇文章之前，我对闭包的理解也是模棱两可。只是知道闭包的用法，而关于闭包如何产生的，以及为什么会出现闭包则不大清楚。最近通过看一些博文以及JavaScript高级程序设计，可以说是简单的知道了闭包的原理，所以迫不及待的想要分享一下... ...

`闭包`，一听就是个令人头大的问题。

但是我们却又不得不去面对它。在实际应用以及面试当中，闭包无处不在，甚至可以说它们是衡量js工程师实力的一个重要指标。

正式开始之前，先来两盘开胃菜：
- 执行环境（函数调用栈）
- 作用域

## 执行环境

**执行环境**是 JavaScript 中最为重要的一个概念：

- **执行环境定义了变量或函数有权访问的数据**

- **每个执行环境都有一个与之关联的 变量对象（VO） ，环境中定义的所有变量和函数都保存在这个对象中。**
> 虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 

- **某个执行环境中的所有代码执行完 毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁**
### 全局执行环境
首先，全局执行环境是最外围的一个执行环境。在 Web 浏览器中，全局执行环境被认为是 `window` 对象
> 全局执行环境直到应用程序退 出——例如关闭网页或浏览器——时才会被销毁

### 函数执行环境
每个函数也都有自己的执行环境，当执行流进入一个函数时，函数的执行环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。
::: tip
环境栈也有人称做它为**函数调用栈**
:::

整个过程大概就先下面这样：
<Picture src="stack.jpg"/>
### 变量对象与活动对象
每个执行环境都有一个表示变量的对象**变量对象（VO）**，这个对象里储存着在当前环境中所有的`变量` `函数` `参数`。

全局环境的**变量对象**始终存在，而函数的局部环境的**变量对象**，则只在函数执行的过程中存在。

在函数开始执行时，变量对象转变为**活动对象（AO）**。
> 活动对象实际就是变量对象在真正执行时的另一种形式。

活动对象在最开始时只包含一个变量，即 `arguments` 对象(这个对象在全局环境中是不存在的)。


让我们举下面一个例子：
```jsx harmony
 function foo (a){
    let b = 12;
    return a+b;
 }

```
- 在 foo 函数的环境中，有三个**变量对象**，首先是`arguments ['a']`，然后是变量`a`和`b`。

- 在执行阶段，他们都属于foo的**活动对象**。
## 作用域
- 在 JavaScript 中，我们可以将**作用域**定义为一套**规则**,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。
> 这里的标识符，指的是变量名或者函数名

- JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)

::: tip
**作用域**与**执行上下文**是完全不同的两个概念。很多人会混淆他们，但是一定要仔细区分。
:::
- JavaScript代码的整个执行过程，分为两个阶段，**代码编译**阶段与**代码执行**阶段。
    - 编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段**作用域规则会确定**。
    - 执行阶段由引擎完成，主要任务是执行可执行代码，**执行上下文在这个阶段创建**。
## 作用域链
- **当代码在一个环境中执行时，会创建变量对象的一个作用域链，这个作用域链被保存在内部的`[[Scope]]`属性中**

- **作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。**

- **作用域链的前端，始终都是当前执行的代码所在环境的变量对象。**
- **下一个变量对象来自外部环境，而再下一个变量对象则来自下一个包含环境。**
- **最末端始终都是全局变量对象。**

这么说可能有点模糊，请看下面的示例代码:
```jsx harmony
var color = "blue";
    function changeColor(){
        var anotherColor = "red";
        function swapColors(){
            var tempColor = anotherColor;
            anotherColor = color;
            color = tempColor;
            // 这里可以访问color、anotherColor和tempColor 
        }
            // 这里可以访问color和anotherColor，但不能访问tempColor
        swapColors();
   }
// 这里只能访问color 
changeColor();
```
以上代码共涉及 3 个执行环境:`全局环境`，`changeColor局部环境`，`swapColors局部环境`。

- 全局环境中有一个变量 `color` 和一个函数 `changeColor`

- `changeColor`的局部环境中有 一个名为 `anotherColor` 的变量和一个名为 `swapColors`的函数

- `swapColors`的局部环境中有一个变量 `tempColor`

我们设定它们的变量对象分别为` VO（global）`，`VO（changeColor）`，`VO（swapColors）`

两个函数的执行上下文可如下表示：
```jsx harmony
changeColor = {
  VO:{...}, //变量对象
  scopeChain:[VO(changeColor),VO(global)]
}

swapColors = {
  VO:{...}, //变量对象
  scopeChain:[VO(swapColors),VO(changeColor),VO(global)]
}
```
我们可以直接用一个数组来表示作用域链，数组的第一项`scopeChain[0]`为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。

**到这里我们应该知道：**

- **内部环境**可以通过作用域链访问所有的**外部环境**，**外部环境**不能访问**内部环境**中的任何变量和函数

- 每个环境都可以**向上**搜索作用域链，以查询变量和函数名，但不能**向下**搜索进入另一个执行环境

了解了执行环境以及作用域，让我们来重新认识一下闭包：

## 闭包

> 对于那些有一些 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以功力大增。
### 概念
**闭包是指有权访问另一个函数作用域中的变量的函数。**
### 产生过程
闭包是一种**特殊的对象**，闭包的产生过程如下：
- 存在**执行上下文**`A`
- 在`A`中创建函数（执行上下文）`B`，用返回`B`的方式让`B`在`A`的**环境外**得以执行
- `A`出栈后，它的**作用域链**被销毁。但由于`VO(A)`仍在`B`的**作用域链**中被引用，所以`VO(A)`会在内存中一直存在
- 这时`VO（A）`就形成了闭包

创建闭包的常见方式，就是在一个函数内部返回另一个函数。让我们通过例子来了解一下：
```js{3}
function getProperty(object) {
        return function(propertyName){
            return object[propertyName]
        }
};
let name = getProperty({name:"123"})("name");
console.log(name) //123
```
在这个例子中，突出的那行代码是内部函数(一个匿名函数)中的代码。

这行代码在`getProperty`出栈后仍访问了其**变量对象** `object`。

### 分析

之所以还能够访问这个变量，就像刚才说的，是匿名函数的作用域链中包含 `getProperty`的变量对象。

**要彻底搞清楚其中的细节，必须从理解函数被调用的时候都会发生什么入手**

#### getProperty：

当 getProperty 被调用时，它的执行环境以及作用域链被创建，可以如下表示:
```jsx harmony
getProperty = {
  VO:{
      arguments :{'name'}],
      propertyName:'name'
  },
  scopeChain:[VO(getProperty),VO(global)]
}
```
#### Anonymous Function

> 在一个函数内部定义的函数会将即外部函数的活动对象添加到它的作用域链中

因此，在 getProperty 函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数 getProperty 的活动对象:
```jsx harmony
Anonymous = {
  VO:{
      arguments :{name:123}],
      object:{name:123}
  },
  scopeChain:[VO(getProperty),VO(global)]
}
```

这样，匿名函数就可以访问在 getProperty 中定义的所有变量。

更为重要的是，getProperty 函数在执行完毕后，`VO(getProperty)`也不会被销毁，**因为匿名函数的作用域链仍然在引用这个活动对象**。

它的**活动对象**仍然会留在内存中，直到匿名函数被销毁。

下图展示了调用 getProperty 过程中产生的作用域之间的关系。
<Picture src="chain.jpg"/>


看到这里，我想我们对闭包已经有了自己的认知。
## 注意
作用域链的这种配置机制引出了一个值得注意的**副作用**，

- 在一个函数中创建的所有函数，它的作用域链中的**父变量对象**都是相同的。

换句话说，闭包所保存的是整个**变量对象**，这个变量对象是**引用类型**，而不是某个特殊的**基本类型**变量。

他们保存的仅仅是一个**指针**，这些指针都指向存储在堆中的**同一区域**。任何对这个变量的修改，在其他地方都会得到体现。

下面这个例子可以清晰地说 明这个问题，而且这种题目我们在一些经典面试题中也经常见到。
```jsx harmony
function createFunctions(){
    var result = new Array();
    for (var i=0; i < 10; i++){
        result[i] = function(){
          return i; 
        };
    }
    return result;
}
```
这个函数会返回一个函数数组，表面上看，每个函数都有自己的索引，他们的执行结果也刚好是他们的索引值。

但实际结果与我们的设想大相径庭，尝试打印result，将会发现控制台输出了10个10。

### 问题分析

问题的关键就在于，每个子函数的作用与链中保存的都是`VO(createFunctions)`，这是一个引用类型的对象，他们在内存中的地址是一样的。

createFunctions 返回后，`VO（createFunctions）`中的`i`变成了10。

此时每个子函数沿作用域向上查找，得到的结果也都是10。

### 解决方案

我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示。
```jsx harmony
function createFunctions(){
    var result = new Array();
    for (var i=0; i < 10; i++){
        result[i] = function(num){
          return function (){
            return num
          }
        }(i)
    }
    return result;
}
```
在这个版本中，我们并没有直接把 `VO（createFunctions）`中的`i`赋值给数组，而是定义了一个立即执行匿名函数，并将`i`作为匿名函数的参数赋值给数组。

在每个立即执行函数被调用时，我们传入了不同的变量`i`,每个立即执行匿名函数 **马上** 生成自己 **活动对象**，这里的所有 **活动对象** 都是完全独立的，其中的`num`也都是刚刚被传入的`i`的值。

这时`num`形成了一个新的**闭包**,

所以最终的数组函数被调用时，它在作用域链中依次向上查找变量`num`，
首先查找到的是我们定义的立即执行匿名函数的`活动对象`中的`num`。

他们每一个`活动对象`都是独立的，因此该方法能够正确的返回1至10。
