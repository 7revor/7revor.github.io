## 锲子
> 写这篇文章之前，我对闭包的理解也是模棱两可。只是知道闭包的用法，而关于闭包如何产生的，以及为什么会出现闭包则不大清楚。最近通过看一些博文以及JavaScript高级程序设计，可以说是简单的知道了闭包的原理，所以迫不及待的想要分享一下... ...

`闭包`，一听就是个令人头大的问题。

但是我们却又不得不去面对它。在实际应用以及面试当中，闭包无处不在，甚至可以说它们是衡量js工程师实力的一个重要指标。

正式开始之前，先来两盘开胃菜：
- 执行环境（函数调用栈）
- 作用域

## 执行环境

**执行环境**是 JavaScript 中最为重要的一个概念：

- **执行环境定义了变量或函数有权访问的数据**

- **每个执行环境都有一个与之关联的 变量对象 ，环境中定义的所有变量和函数都保存在这个对象中。**
> 虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 

- **某个执行环境中的所有代码执行完 毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁**
### 全局执行环境
首先，全局执行环境是最外围的一个执行环境。在 Web 浏览器中，全局执行环境被认为是 `window` 对象
> 全局执行环境直到应用程序退 出——例如关闭网页或浏览器——时才会被销毁

### 函数执行环境
每个函数也都有自己的执行环境，当执行流进入一个函数时，函数的执行环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。
::: tip
环境栈也有人称做它为**函数调用栈**，函数执行环境也有人称它为**作用域**
:::

整个过程大概就先下面这样：
<Picture src="stack.jpg"/>
### 变量对象与活动对象
每个执行环境都有一个表示变量的对象**变量对象**，这个对象里储存着在当前环境中所有的`变量` `函数` `参数`。

全局环境的**变量对象**始终存在，而函数的局部环境的**变量对象**，则只在函数执行的过程中存在。

在函数开始执行时，变量对象转变为**活动对象**。

活动对象在最开始时只包含一个变量，即 `arguments` 对象(这个对象在全局环境中是不存在的)。

> 活动对象实际就是变量对象在真正执行时的另一种形式。

让我们举下面一个例子：
```jsx harmony
 function foo (a){
    let b = 12;
    return a+b;
 }

```
- 在 foo 函数的环境中，有两个**变量对象**，首先是`arguments ['a']`，然后是变量 `b`。

- 在执行阶段，他们都属于foo的**活动对象**。
## 作用域
**当代码在一个环境中执行时，会创建变量对象的一个作用域链，这个作用域链被保存在内部的`[[Scope]]`属性中**

**作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。**

**作用域链的前端，始终都是当前执行的代码所在环境的变量对象。**

**如果这个环境是函数，则将其活动对象(activation object)作为变量对象。**

**作用域链中 的下一个变量对象来自外部环境，而再下一个变量对象则来自下一个包含环境。**

**全局执行环境的变量对象始终都是作用域链中的最后一个对象。**

请看下面的示例代码:
```jsx harmony
var color = "blue";
    function changeColor(){
        var anotherColor = "red";
        function swapColors(){
            var tempColor = anotherColor;
            anotherColor = color;
            color = tempColor;
            // 这里可以访问color、anotherColor和tempColor 
        }
            // 这里可以访问color和anotherColor，但不能访问tempColor
        swapColors();
   }
// 这里只能访问color 
changeColor();
```
以上代码共涉及 3 个执行环境:全局环境，`changeColor`的局部环境和`swapColors`的局部环境。

- 全局环境中有一个变量 `color` 和一个函数 `changeColor`

- `changeColor`的局部环境中有 一个名为 `anotherColor` 的变量和一个名为 `swapColors`的函数

- `swapColors`的局部环境中有一个变量 `tempColor`

两个函数的作用域链为：
- `changeColor`：**changeColor的变量对象** `=>` **全局变量对象**
- `swapColors`：**swapColors的变量对象** `=>` **changeColor的变量对象** `=>` **全局变量对象**

到这里我们应该知道：

**内部环境可以通过作用域链访问所有的外部环境**

**外部环境不能访问内部环境中的任何变量和函数**

**每个环境都可以向上搜索作用域链，以查询变量和函数名**

**任何环境都不能通过向下搜索作用域链而进入另一个执行环境**

**作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象**

**无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量**

了解了执行环境以及作用域，让我们来重新认识一下闭包：

## 闭包


**闭包是指有权访问另一个 函数作用域中的变量的函数。**

### 访问`“不存在的”`变量
创建闭包的常见方式，就是在一个函数内部返回另一个函数。让我们通过例子来了解一下：
```js{3}
function getProperty(object) {
        return function(propertyName){
            return object[propertyName]
        }
};
let name = getProperty({name:"123"})("name");
console.log(name) //123
```
在这个例子中，突出的那行代码是内部函数(一个匿名函数)中的代码。

这行代码访问了外部函数中的变量 `propertyName`。

按照我们刚猜的逻辑，在`getProperty`执行完毕后，它的作用域就被推出执行环境，而它的变量对象也将被销毁。但为什么仍然可以访问变量 `propertyName`？

### 发生了什么

之所以还能够访问这个变量，是匿名函数的作用域链中包含 `getProperty`的作用域。

**要彻底搞清楚其中的细节，必须从理解函数被调用的时候 都会发生什么入手**

#### getProperty：

当 getProperty 被调用时，它的执行环境以及作用域链被创建，它的变量对象为:
- arguments :`[{name:123}]`
- object: `{name:123}`

它的作用域链为：`getProperty的变量对象` => `全局变量对象`
#### Anonymous Function
> 在一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用域链中

因此，在 getProperty 函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数 getProperty 的活动对象:

`Anonymous的变量对象` => `getProperty的变量对象` => `全局变量对象`。

这样，匿名函数就可以访问在 getProperty 中定义的所有变量。

更为重要的是，getProperty 函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。

换句话说，当 getProperty 函数返回后，其执行环境的作用域链会被销毁，但它的**活动对象**仍然会留在内存中。

直到匿名函数被销毁后，getProperty 的活动对象才会被销毁。

下图展示了调用 getProperty 过程中产生的作用域之间的关系。
<Picture src="chain.jpg"/>

## 注意

作用域链的这种配置机制引出了一个值得注意的副作用，
即闭包只能取得包含函数中任何变量的最后一个值。也就是说，

**在一个函数中创建的所有函数，它的作用域链中的父变量对象都是相同的。**

别忘了闭包所保存的是整个**变量对象**，而不是某个特殊的变量。下面这个例子可以清晰地说 明这个问题，而且这种题目我们在一些经典面试题中也经常见到。
```jsx harmony
function createFunctions(){
    var result = new Array();
    for (var i=0; i < 10; i++){
        result[i] = function(){
          return i; 
        };
    }
    return result;
}
```
这个函数会返回一个函数数组，表面上看，每个函数都有自己的索引，他们的执行结果也刚好是他们的索引值。

但实际结果与我们的设想大相径庭，尝试打印result，将会发现控制台输出了10个10。

### 问题分析

问题的关键就在于，每个子函数的作用与链中保存的都是 createFunctions 函数的`活动对象`，他们只是引用不同，而在内存中的地址是一样的。
而，在`createFunctions`执行完后，`i`变成了10，他们执行时沿作用域向上查找，得到的结果也都是10。

### 解决方案

我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示。
```jsx harmony
function createFunctions(){
    var result = new Array();
    for (var i=0; i < 10; i++){
        result[i] = function(num){
          return function (){
            return num
          }
        }(i)
    }
    return result;
}
```
在这个版本中，我们并没有直接把 createFunctions 的函数变量`i`赋值给数组，而是定义了一个立即执行匿名函数，并将`i`作为匿名函数的参数赋值给数组。

在每个立即执行函数被调用时，我们传入了不同的变量`i`,每个立即执行匿名函数立即生成自己的独立`活动对象`，`活动对象`中的`num`也都是刚刚被传入的`i`的值。

这里的`i`形成了一个新的**闭包**，所以最终的数组函数被调用时，它在作用域链中依次向上查找变量`num`，
首先查找到的是我们定义的立即执行匿名函数的`活动对象`中的`num`。

他们内部的`活动对象`都是完全独立的，因此该方法能够正确的返回1至10。
